# Pytorch——Tensor

张量是一个多位数组或者n维数组，Tensors 类似于 NumPy 的 ndarrays ，同时 Tensors 可以使用 GPU 进行计算。


```python
import torch 
```

## Tensor基本用法

# #构造矩阵

每个torch.Tensor都有torch.dtype, torch.device,和torch.layout
torch.dtype是表示torch.Tensor的数据类型的对象。
torch.device代表将torch.Tensor分配到的设备的对象。比如cpu和gup。
require_grad（布尔型，可选）：如果autograd应该在返回的张量上记录操作。 默认值：False。
pin_memory（布尔型，可选）：如果设置将返回的张量将在固定的内存中分配。 仅适用于CPU张量。 默认值：False。

### 构造未初始化矩阵

torch.Tensor(5,3)   和   torch.empty(5,3)

两种方法都构造5*3 矩阵，只是分配了空间，未初始化,所以里面的内容是随机的


```python
#构造5*3 矩阵，只是分配了空间，未初始化,所以里面的内容是随机的
x = torch.Tensor(5,3)
print(x)
```

    tensor([[1.0286e-38, 1.0653e-38, 1.0194e-38],
            [8.4490e-39, 1.0469e-38, 9.3674e-39],
            [9.9184e-39, 8.7245e-39, 9.2755e-39],
            [8.9082e-39, 9.9184e-39, 8.4490e-39],
            [9.6429e-39, 1.0653e-38, 1.0469e-38]])
    


```python
x = torch.empty(5,3)
print(x)
```

    tensor([[1.0286e-38, 1.0653e-38, 1.0194e-38],
            [8.4490e-39, 1.0469e-38, 9.3674e-39],
            [9.9184e-39, 8.7245e-39, 9.2755e-39],
            [8.9082e-39, 9.9184e-39, 8.4490e-39],
            [9.6429e-39, 1.0653e-38, 1.0469e-38]])
    

### 构造初始化矩阵

1、torch.rand()  使用[0,1] 均匀分步随机初始化三维数组


```python
#使用[0,1] 均匀分步随机初始化三维数组
x = t.rand(2,3,4)
print(x)
```

    tensor([[[0.2961, 0.0654, 0.4998, 0.8690],
             [0.2853, 0.3166, 0.0107, 0.8539],
             [0.1544, 0.0815, 0.1460, 0.9378]],
    
            [[0.9472, 0.0081, 0.2933, 0.7905],
             [0.1456, 0.7825, 0.7814, 0.3340],
             [0.5613, 0.6676, 0.8027, 0.5231]]])
    

2、torch.zeros()    构造一个数据全为0的矩阵，而且可以设置数据类型

 
torch.ones()    构造一个数据全为1的矩阵


```python
x = torch.zeros(5,3,dtype = torch.long)
print(x)
y = torch.ones(5,3,dtype = torch.float)
print(y)
```

    tensor([[0, 0, 0],
            [0, 0, 0],
            [0, 0, 0],
            [0, 0, 0],
            [0, 0, 0]])
    tensor([[1., 1., 1.],
            [1., 1., 1.],
            [1., 1., 1.],
            [1., 1., 1.],
            [1., 1., 1.]])
    

3、直接使用数据构建一个张量


```python
x = torch.tensor([5.5,3])
print(x)
```

    tensor([5.5000, 3.0000])
    

4、基于已初始化的tensor创建一个新的tensor


```python
x = x.new_ones(5,3,dtype=torch.double)
print(x)

x = x.new_zeros(5,3,dtype=torch.int)
print(x)

x = torch.randn_like(x,dtype=torch.float)
print(x)
```

    tensor([[1., 1., 1.],
            [1., 1., 1.],
            [1., 1., 1.],
            [1., 1., 1.],
            [1., 1., 1.]], dtype=torch.float64)
    tensor([[0, 0, 0],
            [0, 0, 0],
            [0, 0, 0],
            [0, 0, 0],
            [0, 0, 0]], dtype=torch.int32)
    tensor([[ 1.3249,  1.1315, -0.4940],
            [ 0.1993,  0.8352, -1.4315],
            [ 1.2686,  0.3988, -0.8833],
            [-1.4513,  1.4642, -1.0341],
            [-0.2035,  2.0559,  0.3357]])
    

### 张量的运算

torch.Tensor 支持大量的数学操作符 + , - , * , / 都是可以用的。


```python
print(x)

#下面样式进行的操作是会对张量里面的每一个数据都进行
print(x+1)
print(x-1)
print(x*2)
print(x/2)
```

    tensor([[ 1.3249,  1.1315, -0.4940],
            [ 0.1993,  0.8352, -1.4315],
            [ 1.2686,  0.3988, -0.8833],
            [-1.4513,  1.4642, -1.0341],
            [-0.2035,  2.0559,  0.3357]])
    tensor([[ 2.3249,  2.1315,  0.5060],
            [ 1.1993,  1.8352, -0.4315],
            [ 2.2686,  1.3988,  0.1167],
            [-0.4513,  2.4642, -0.0341],
            [ 0.7965,  3.0559,  1.3357]])
    tensor([[ 0.3249,  0.1315, -1.4940],
            [-0.8007, -0.1648, -2.4315],
            [ 0.2686, -0.6012, -1.8833],
            [-2.4513,  0.4642, -2.0341],
            [-1.2035,  1.0559, -0.6643]])
    tensor([[ 2.6498,  2.2630, -0.9879],
            [ 0.3986,  1.6704, -2.8630],
            [ 2.5372,  0.7976, -1.7665],
            [-2.9027,  2.9285, -2.0683],
            [-0.4070,  4.1119,  0.6713]])
    tensor([[ 0.6624,  0.5657, -0.2470],
            [ 0.0997,  0.4176, -0.7158],
            [ 0.6343,  0.1994, -0.4416],
            [-0.7257,  0.7321, -0.5171],
            [-0.1017,  1.0280,  0.1678]])
    

加法操作的四种方式：


```python
y = torch.rand(5,3)
print(x)
print(y)
```

    tensor([0.6424])
    tensor([[0.8245, 0.3493, 0.5470],
            [0.3498, 0.4025, 0.2216],
            [0.3241, 0.3299, 0.4923],
            [0.7845, 0.9954, 0.3048],
            [0.9815, 0.0631, 0.5087]])
    


```python
#第一种方式，直接相加
print(x+y)

#第二种方式，使用add函数
print(torch.add(x,y))
```

    tensor([[1.4669, 0.9917, 1.1894],
            [0.9922, 1.0448, 0.8640],
            [0.9665, 0.9723, 1.1347],
            [1.4269, 1.6378, 0.9472],
            [1.6239, 0.7055, 1.1511]])
    tensor([[1.4669, 0.9917, 1.1894],
            [0.9922, 1.0448, 0.8640],
            [0.9665, 0.9723, 1.1347],
            [1.4269, 1.6378, 0.9472],
            [1.6239, 0.7055, 1.1511]])
    


```python
#第三种方式，提供一个输出tensor作为参数
result = torch.randn(5,3)     #先分配空间
torch.add(x,y,out = result)
print(result)

#第四种方法，函数名后面带下划线_的函数会修改Tensor本身。例如x.add_()和x.t()。x.t()表示取转置矩阵
y.add_(x)
print(y)
```

    tensor([[1.4669, 0.9917, 1.1894],
            [0.9922, 1.0448, 0.8640],
            [0.9665, 0.9723, 1.1347],
            [1.4269, 1.6378, 0.9472],
            [1.6239, 0.7055, 1.1511]])
    tensor([[1.4669, 0.9917, 1.1894],
            [0.9922, 1.0448, 0.8640],
            [0.9665, 0.9723, 1.1347],
            [1.4269, 1.6378, 0.9472],
            [1.6239, 0.7055, 1.1511]])
    

对于常用的矩阵运算Tensor也有很好的支持


```python
x = torch.Tensor([[1,2,3],[4,5,6]])
y = torch.randn(2,3)

print("x:",x)
print("y:",y)
```

    x: tensor([[1., 2., 3.],
            [4., 5., 6.]])
    y: tensor([[ 0.5770,  1.2614,  0.9343],
            [-1.1013, -0.6507,  2.3107]])
    


```python
#矩阵乘法，其中t()表示取转置.当矩阵A的行数等于矩阵B的列数时，A,B可以相乘。
#乘出来的矩阵行数等于A的行数，列数等于B的列数
#矩阵C的第m行din列的元素等于矩阵A第m行元素与矩阵B的第n列元素乘积之和
torch.mm(x,y.t())
```




    tensor([[ 5.9027,  4.5295],
            [14.2209,  6.2057]])



跟numpy一样，再Tensor中，也存在Broadcasting

当二元操作符左右两边Tensor形状不一样的时候，系统会尝试将其复制到一个共同的形状。例如a的第0维是3, b的第0维是1，那么 a + b这个操作会将c扩展为最大行和最大列的矩阵，将所有的数据都加一遍



```python
a = torch.arange(0,3).view(3,1)
b = torch.arange(0,2).view(1,2)
c = a+b

print("a:",a)
print("b:",b)
print("c:",c)
print(c.size())
```

    a: tensor([[0],
            [1],
            [2]])
    b: tensor([[0, 1]])
    c: tensor([[0, 1],
            [1, 2],
            [2, 3]])
    torch.Size([3, 2])
    

### 张量的形状

查看：使用.size() 方法可以查看张量的形状，相当于numpy中的shape（）方法

torch.Size是tuple的子类，因此支持tuple的所有操作。


```python
print(x)
print(x.size())
print(x.size()[0],x.size()[1])
```

    tensor([[ 1.3249,  1.1315, -0.4940],
            [ 0.1993,  0.8352, -1.4315],
            [ 1.2686,  0.3988, -0.8833],
            [-1.4513,  1.4642, -1.0341],
            [-0.2035,  2.0559,  0.3357]])
    torch.Size([5, 3])
    5 3
    

改变：如果你想改变一个 tensor 的大小或者形状，你可以使用 torch.view


```python
x = torch.randn(4,4)
y = x.view(16)
z = x.view(-1,8)    #-1  会自动填写适合的数字
print(x.size(),y.size(),z.size())
```

    torch.Size([4, 4]) torch.Size([16]) torch.Size([2, 8])
    

获值：如果一个tensor中只有一个元素，使用.item()可以获得这个value。


```python
x = torch.randn(1)
print(x)
print(x.item())
```

    tensor([0.6424])
    0.6423922777175903
    

### Tensor 和Numpy的相互转换

Tensor 和Numpy的数组间相互转换操作非常容易且快速.Tensor 不支持的操作，可以先转换为numpy数组处理，之后再转回Tensor

torch.from_numpy(data)   将数据从numpy转为tensor

data.numpy()   即可将tensor数据转换为numpy


```python
import numpy as np
```


```python
x = np.ones((2,3))
print("x:",x)

y = torch.from_numpy(x)    #Numpy->Tensor
print("y:",y)

z = y.numpy()       #Tensor ->Numpy
print("z:",z)
```

    x: [[1. 1. 1.]
     [1. 1. 1.]]
    y: tensor([[1., 1., 1.],
            [1., 1., 1.]], dtype=torch.float64)
    z: [[1. 1. 1.]
     [1. 1. 1.]]
    

Tensor  和 numpy 共享内存，其中一个变了，另一个也会改变


```python
y.add_(1)

print(x)
print(y)
```

    [[2. 2. 2.]
     [2. 2. 2.]]
    tensor([[2., 2., 2.],
            [2., 2., 2.]], dtype=torch.float64)
    

Tensor 可通过 .cuda 方法转为GPU的tensor，从而享受到GPU带来的加速运算.
当大规模数据和复杂运算时会体现出效果。


```python
#如果不支持CUDA的设备，则不会运行
if t.cuda.is_available():
    x = x.cuda()
    y = y.cuda()
    x+y
```
