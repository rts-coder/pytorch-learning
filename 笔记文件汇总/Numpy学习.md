---
typora-copy-images-to: 笔记保存图片
---

# Numpy学习

处理数值数据

## 介绍

numpy可以理解为一个可以实现科学计算的包

![](D:\任太帅的日常文件\研究生学习课程\深度学习笔记\pytorch学习笔记\笔记保存图片\image-20201020220310634.png)



## 创建数组（矩阵）

![image-20201020221324780](D:\任太帅的日常文件\研究生学习课程\深度学习笔记\pytorch学习笔记\笔记保存图片\image-20201020221324780.png)

创建数组

三种方法：

1、np.array([])     传入数组

2、np.array(range(n)，dtype=None)    使用range函数直接生成0到n-1的整数

3、np.arange([start,] stop[,step,],dtype=None) 		arange函数，可设置步长



数组的类名是ndarray，数组中的数据类型可以使用 .dype  查看。

```python
import numpy as np

#使用numpy生成数组，得到ndarray的类型
t1 = np.array([1,2,3])
print(t1)
print(type(t1))

t2 = np.array(range(10))    #数值范围为从0 到9
print(t2)
print(type(t2))

t3 = np.arange(10)          #数值范围和上面的range一样，都是从0到9
print(t3)
print(type(t3))

t4 = np.arange(4,10,2)      #设置了步长为2的从4到10的数组，左闭右开
print(t4)
print(type(t4))
print(t4.dtype)         #数组中数据的类型


#运行结果：
[1 2 3]
<class 'numpy.ndarray'>
[0 1 2 3 4 5 6 7 8 9]
<class 'numpy.ndarray'>
[0 1 2 3 4 5 6 7 8 9]
<class 'numpy.ndarray'>
[4 6 8]
<class 'numpy.ndarray'>
int32
```

numpy中常见的更多数据类型

![image-20201020222731434](D:\任太帅的日常文件\研究生学习课程\深度学习笔记\pytorch学习笔记\笔记保存图片\image-20201020222731434.png)

数据类型的操作

![image-20201021105149050](D:\任太帅的日常文件\研究生学习课程\深度学习笔记\pytorch学习笔记\笔记保存图片\image-20201021105149050.png)

numpy中可以通过dtype设置数据类型,通过dtype可以设置为各种类型，包括bool类型

可以使用  .satype()   可以调整数据类型

round( x [, n]  )   可以返回浮现数x的四舍五入值，n是保留几位小数

```python
#numpy 中的数据类型
t5 = np.array(range(1,4),dtype="float32")
print(t5)
print(t5.dtype)

#numpy 中的bool类型
t6 = np.array([1,0,1,0,0,1],dtype=bool)
print(t6)
print(t6.dtype)

##调整数据类型
t7 = t6.astype("int8")
print(t7)
print(t7.dtype)

t8 = np.array([random.random() for i in range(10)])   #生成10个0倒1的随机数
print(t8)
print(t8.dtype)

t9 = np.round(t8,2)         #取两位小数
print(t9)

#运行结果

float32
[ True False  True False False  True]
bool
[1 0 1 0 0 1]
int8
[0.86176226 0.32485614 0.13412926 0.01589083 0.88897626 0.62804737
 0.06260431 0.87683537 0.1284273  0.00578656]
float64
[0.86 0.32 0.13 0.02 0.89 0.63 0.06 0.88 0.13 0.01]
```

## 数组的计算

### shape和reshape

![image-20201021171106691](D:\任太帅的日常文件\研究生学习课程\深度学习笔记\pytorch学习笔记\笔记保存图片\image-20201021171106691.png)

![image-20201027193348303](D:\任太帅的日常文件\研究生学习课程\深度学习笔记\pytorch学习笔记\笔记保存图片\image-20201027193348303.png)

使用.shape   属性可以查看数组的形状，里面有几个数表示的就是几维数组。

```python
import numpy as np

t1 = np.arange(12)

t1
Out[2]: array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])

t1.shape
Out[3]: (12,)

t2 = np.array([[1,2,3],[4,5,6]])

t2
Out[5]: 
array([[1, 2, 3],
       [4, 5, 6]])

t2.shape
Out[6]: (2, 3)			#这里的数字代表行、列

t3 = np.array([[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]])

t3
Out[8]: 
array([[[ 1,  2,  3],
        [ 4,  5,  6]],

       [[ 7,  8,  9],
        [10, 11, 12]]])

t3.shape
Out[9]: (2, 2, 3)
```

t.shape[0]   表示的行列式的行数， t.shpape[1]  表示的行列式的列数

```python
t5
Out[19]: 
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],

       [[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]]])

t5.shape[0]
Out[20]: 2

t5.shape[1]
Out[21]: 3
```



修改数组形状，使用reshape()。reshape的括号总可以是括号括起来的数据，也可以是直接逗号分开的数据。重新改变形状之后的数据个数总和不变。

reshape（）方法不会改变原先的数组本身，只会返回一个新的矩阵。

三维数据，第一个数字可以理解为块，有多少块。第二个数字为行，第三个为列。

```python 
t4 = np.arange(12)

t4
Out[12]: array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])

t4.reshape((3,4))
Out[13]: 
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])

t4.reshape(3,5)
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-14-7ee0b0938333> in <module>
----> 1 t4.reshape(3,5)

ValueError: cannot reshape array of size 12 into shape (3,5)

t5 = np.arange(24).reshape((2,3,4))

t5
Out[16]: 
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],

       [[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]]])


#以下是不同格式的写法

t5.reshape(24,)
Out[10]: 
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
       17, 18, 19, 20, 21, 22, 23])

t5.reshape(24,1)
Out[11]: 
array([[ 0],
       [ 1],
       [ 2],
       [ 3],
       [ 4],
       [ 5],
       [ 6],
       [ 7],
       [ 8],
       [ 9],
       [10],
       [11],
       [12],
       [13],
       [14],
       [15],
       [16],
       [17],
       [18],
       [19],
       [20],
       [21],
       [22],
       [23]])

t5.reshape(1,24)
Out[12]: 
array([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23]])

```

展开函数.flatten()。使用此方法可以是一个行列式展开为一维数组的行列式。

t6 = t5.reshape((t5.shape[0]*t5.shape[1]*t5.shape[2],))   也是将其转换为一维行列式

```python
t5
Out[35]: 
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],

       [[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]]])

t5.reshape(1,24)
Out[36]: 
array([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23]])

t5.shape[0]
Out[37]: 2

t5.shape[1]
Out[38]: 3

t5.shape[2]
Out[39]: 4

t6 = t5.reshape((t5.shape[0]*t5.shape[1]*t5.shape[2],))

t6
Out[41]: 
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
       17, 18, 19, 20, 21, 22, 23])

#t5.flatten()  可以起到和上面统计t5中个题总数的作用

t5.flatten()
Out[43]: 
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
       17, 18, 19, 20, 21, 22, 23])
```

### 加减乘除

![image-20201027200427995](D:\任太帅的日常文件\研究生学习课程\深度学习笔记\pytorch学习笔记\笔记保存图片\image-20201027200427995.png)

![image-20201027200443707](D:\任太帅的日常文件\研究生学习课程\深度学习笔记\pytorch学习笔记\笔记保存图片\image-20201027200443707.png)

![image-20201027200501552](D:\任太帅的日常文件\研究生学习课程\深度学习笔记\pytorch学习笔记\笔记保存图片\image-20201027200501552.png)

![image-20201027200513738](D:\任太帅的日常文件\研究生学习课程\深度学习笔记\pytorch学习笔记\笔记保存图片\image-20201027200513738.png)

广播原则![image-20201027200629584](D:\任太帅的日常文件\研究生学习课程\深度学习笔记\pytorch学习笔记\笔记保存图片\image-20201027200629584.png)



矩阵的加减乘除是每个个体数字都要进行相应的加减乘除。就算除0也不会报错，但会提醒。

nan  :  not a  number   不是一个数字

inf：infinite      无线，无穷

```python
import numpy as np


t1 = np.arange(24).reshape((4,6))

t1
Out[4]: 
array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11],
       [12, 13, 14, 15, 16, 17],
       [18, 19, 20, 21, 22, 23]])

t1+2
Out[5]: 
array([[ 2,  3,  4,  5,  6,  7],
       [ 8,  9, 10, 11, 12, 13],
       [14, 15, 16, 17, 18, 19],
       [20, 21, 22, 23, 24, 25]])

t1-2
Out[6]: 
array([[-2, -1,  0,  1,  2,  3],
       [ 4,  5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14, 15],
       [16, 17, 18, 19, 20, 21]])

t1*2
Out[7]: 
array([[ 0,  2,  4,  6,  8, 10],
       [12, 14, 16, 18, 20, 22],
       [24, 26, 28, 30, 32, 34],
       [36, 38, 40, 42, 44, 46]])

t1/2
Out[8]: 
array([[ 0. ,  0.5,  1. ,  1.5,  2. ,  2.5],
       [ 3. ,  3.5,  4. ,  4.5,  5. ,  5.5],
       [ 6. ,  6.5,  7. ,  7.5,  8. ,  8.5],
       [ 9. ,  9.5, 10. , 10.5, 11. , 11.5]])

t1/0
<ipython-input-9-f93ec182d5ab>:1: RuntimeWarning: divide by zero encountered in true_divide
  t1/0
<ipython-input-9-f93ec182d5ab>:1: RuntimeWarning: invalid value encountered in true_divide
  t1/0
Out[9]: 
array([[nan, inf, inf, inf, inf, inf],
       [inf, inf, inf, inf, inf, inf],
       [inf, inf, inf, inf, inf, inf],
       [inf, inf, inf, inf, inf, inf]])
```

当形状相同的行列式相加时，相同部位的数字相加减或者乘除。

```python
t1
Out[10]: 
array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11],
       [12, 13, 14, 15, 16, 17],
       [18, 19, 20, 21, 22, 23]])

t2 = np.arange(100,124).reshape((4,6))

t2
Out[12]: 
array([[100, 101, 102, 103, 104, 105],
       [106, 107, 108, 109, 110, 111],
       [112, 113, 114, 115, 116, 117],
       [118, 119, 120, 121, 122, 123]])

t1+t2
Out[13]: 
array([[100, 102, 104, 106, 108, 110],
       [112, 114, 116, 118, 120, 122],
       [124, 126, 128, 130, 132, 134],
       [136, 138, 140, 142, 144, 146]])
```

当数组有相同的行或者相同的列时，系统会判定可以进行计算。但两个数组没有共同的行或者列的时候则不能参与计算。

此处为广播原则，从后往前数，有相同数字或者其中的数字为1。则认为是广播兼容的。

```python
t1
Out[20]: 
array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11],
       [12, 13, 14, 15, 16, 17],
       [18, 19, 20, 21, 22, 23]])

t2 = np.arange(0,6)

t2
Out[22]: array([0, 1, 2, 3, 4, 5])

t1-t2
Out[23]: 
array([[ 0,  0,  0,  0,  0,  0],
       [ 6,  6,  6,  6,  6,  6],
       [12, 12, 12, 12, 12, 12],
       [18, 18, 18, 18, 18, 18]])

t3 = np.arange(4).reshape(4,1)

t3
Out[25]: 
array([[0],
       [1],
       [2],
       [3]])

t1-t3
Out[26]: 
array([[ 0,  1,  2,  3,  4,  5],
       [ 5,  6,  7,  8,  9, 10],
       [10, 11, 12, 13, 14, 15],
       [15, 16, 17, 18, 19, 20]])

t4 = np.arange(10)

t4
Out[28]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

t1- t4
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-29-aba345759db1> in <module>
----> 1 t1- t4

ValueError: operands could not be broadcast together with shapes (4,6) (10,)
```

## 读取本地数据和索引

轴的概念，有点类似于数学中的坐标轴

## ![image-20201029205519778](D:\任太帅的日常文件\研究生学习课程\深度学习笔记\pytorch学习笔记\笔记保存图片\image-20201029205519778.png)

![image-20201029205614759](D:\任太帅的日常文件\研究生学习课程\深度学习笔记\pytorch学习笔记\笔记保存图片\image-20201029205614759.png)

![image-20201029205739451](D:\任太帅的日常文件\研究生学习课程\深度学习笔记\pytorch学习笔记\笔记保存图片\image-20201029205739451.png)

CSV格式的数据，以逗号分隔值文件，每一行数据表示一条记录，逗号和换行来分隔行列的文本。

![image-20201029205947968](D:\任太帅的日常文件\研究生学习课程\深度学习笔记\pytorch学习笔记\笔记保存图片\image-20201029205947968.png)

### np.loadtxt()

frame ：文件       dtype：可以给读入的数据给定格式，比如int、float

delimiter：以书面为分隔符，默认空格，csv需要改成逗号

siprows：跳过前面的多少行

usecoles：读取指定的列

unpack:  若为true，则将读取的数据进行倒置。相当于数组中的倒置

![image-20201029210220963](D:\任太帅的日常文件\研究生学习课程\深度学习笔记\pytorch学习笔记\笔记保存图片\image-20201029210220963.png)



![image-20201029212916507](D:\任太帅的日常文件\研究生学习课程\深度学习笔记\pytorch学习笔记\笔记保存图片\image-20201029212916507.png)

![image-20201029213649374](D:\任太帅的日常文件\研究生学习课程\深度学习笔记\pytorch学习笔记\笔记保存图片\image-20201029213649374.png)



### 倒置

在numpy中实现二维数组转置的其他三种方法

1、.transpose()  方法

```python
t1 = np.arange(24).reshape((4,6))

t1
Out[3]: 
array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11],
       [12, 13, 14, 15, 16, 17],
       [18, 19, 20, 21, 22, 23]])

t1.transpose()
Out[4]: 
array([[ 0,  6, 12, 18],
       [ 1,  7, 13, 19],
       [ 2,  8, 14, 20],
       [ 3,  9, 15, 21],
       [ 4, 10, 16, 22],
       [ 5, 11, 17, 23]])
       
```

2、使用属性T进行转置

```python
t1.T
Out[5]: 
array([[ 0,  6, 12, 18],
       [ 1,  7, 13, 19],
       [ 2,  8, 14, 20],
       [ 3,  9, 15, 21],
       [ 4, 10, 16, 22],
       [ 5, 11, 17, 23]])
```

3、交换二维数组的0和1轴进行交换

```
t1.swapaxes(1,0)
Out[6]: 
array([[ 0,  6, 12, 18],
       [ 1,  7, 13, 19],
       [ 2,  8, 14, 20],
       [ 3,  9, 15, 21],
       [ 4, 10, 16, 22],
       [ 5, 11, 17, 23]])
```



## Numpy索引和切片

![image-20201027201825943](D:\任太帅的日常文件\研究生学习课程\深度学习笔记\pytorch学习笔记\笔记保存图片\image-20201027201825943.png)

取行操作，取得的数据任然是nadrray类型。

通用操作是t[ :  ,  :  ]     逗号前面是行，后面是列。

```python
t1
Out[30]: 
array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11],
       [12, 13, 14, 15, 16, 17],
       [18, 19, 20, 21, 22, 23]])

#取一行
t1[2]
Out[31]: array([12, 13, 14, 15, 16, 17])

  
#取多行
t1[2:]
Out[32]: 
array([[12, 13, 14, 15, 16, 17],
       [18, 19, 20, 21, 22, 23]])


#取任意行，需要使用中括号
t1[[0,2,3]]
Out[33]: 
array([[ 0,  1,  2,  3,  4,  5],
       [12, 13, 14, 15, 16, 17],
       [18, 19, 20, 21, 22, 23]])
```

取列操作

```python
#	取一列

t1[:,0]
Out[38]: array([ 0,  6, 12, 18])

t1
Out[39]: 
array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11],
       [12, 13, 14, 15, 16, 17],
       [18, 19, 20, 21, 22, 23]])

#取多列
t1[:,2:]
Out[40]: 
array([[ 2,  3,  4,  5],
       [ 8,  9, 10, 11],
       [14, 15, 16, 17],
       [20, 21, 22, 23]])

#取不连续的多列
t1[:,[0,2]]
Out[41]: 
array([[ 0,  2],
       [ 6,  8],
       [12, 14],
       [18, 20]])

#取确定的行和列的值

t1
Out[9]: 
array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11],
       [12, 13, 14, 15, 16, 17],
       [18, 19, 20, 21, 22, 23]])

a = t1[3,4]

a
Out[8]: 22

#取第二行到第三行，第二列到第四列的数据，注意这里中括号里面的数据是左闭右开的
t1[1:3,1:4]
Out[10]: 
array([[ 7,  8,  9],
       [13, 14, 15]])

#取多个不连续的点，用两个中括号俩分别记录点的行坐标和列坐标。前后中括号的对应数字分别表示一个点的坐标。
t1
Out[11]: 
array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11],
       [12, 13, 14, 15, 16, 17],
       [18, 19, 20, 21, 22, 23]])

b = t1[[0,0],[1,1]]

b
Out[13]: array([1, 1])

c = t1[[0,2,2],[0,1,3]]

c
Out[15]: array([ 0, 13, 15])
```

## numpy数值修改

修改某个值可以直接赋值就行

![image-20201029215935439](D:\任太帅的日常文件\研究生学习课程\深度学习笔记\pytorch学习笔记\笔记保存图片\image-20201029215935439.png)

某个范围内数据的赋值

```python
t1
Out[16]: 
array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11],
       [12, 13, 14, 15, 16, 17],
       [18, 19, 20, 21, 22, 23]])


t1<10
Out[17]: 
array([[ True,  True,  True,  True,  True,  True],
       [ True,  True,  True,  True, False, False],
       [False, False, False, False, False, False],
       [False, False, False, False, False, False]])

#这里是返回t1中数据小于10的部分
t1[t1<10]
Out[18]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

   
#这里是将t1中数据小于10的部分全部赋值为3，直接在t1数组上修改的
t1[t1<10]=3

t1
Out[20]: 
array([[ 3,  3,  3,  3,  3,  3],
       [ 3,  3,  3,  3, 10, 11],
       [12, 13, 14, 15, 16, 17],
       [18, 19, 20, 21, 22, 23]])
```

三元运算符

np.where(t<10,0,10)  是指将t1中的值，若小于10则赋值为0，若大于10则赋值为10.

![image-20201029220503977](D:\任太帅的日常文件\研究生学习课程\深度学习笔记\pytorch学习笔记\笔记保存图片\image-20201029220503977.png)

```python
np.where(t1<10,0,10)
Out[22]: 
array([[ 0,  0,  0,  0,  0,  0],
       [ 0,  0,  0,  0, 10, 10],
       [10, 10, 10, 10, 10, 10],
       [10, 10, 10, 10, 10, 10]])
```

t1.clip（10,18）方法   

numpy中的裁剪方法，小于10的替换为10，大于10的替换为18.   nan不会被替换

![image-20201029220836419](D:\任太帅的日常文件\研究生学习课程\深度学习笔记\pytorch学习笔记\笔记保存图片\image-20201029220836419.png)

## nan和inf

nan:   当数据有确实的时候就会出现nan，表示这不是一个数据。还有一种情况是当做了一个不合适的计算的时候，比如无穷的相加减。

inf:   当用一个数除以0，python中会报错，numpy中表示是无穷。

![image-20201029221337613](D:\任太帅的日常文件\研究生学习课程\深度学习笔记\pytorch学习笔记\笔记保存图片\image-20201029221337613.png)









